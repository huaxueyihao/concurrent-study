有且有一下三个条件才会出现线程安全问题
1、多线程环境
2、多个线程共享一个资源
3、对资源进行非原子性操作

synchroined:
1、内置锁
2、互斥锁

修饰普通方法、静态方法、修饰代码块

任何对面都可以作为锁，那么所信息存在对象的什么地方？
1、存在对象头中
2、对象头中的信息：Mark Word （锁在这块）、Class Metadata Address(类型地址)、Array Length（数组存在的）

Synchronized：轻量级锁
jdk1.6引入了：
偏向锁：当某个线程持有偏向锁后，执行完代码块，不会释放资源，若是下次还是该线程，则直接进入；若不是，出现竞争，则释放锁
适用场景：只有一个线程访问同步代码的场景
1、每次获取锁和释放锁会浪费资源，
2、很多情况下，竞争锁不是由多个线程，而是由一个线程（相当于单线程在使用）
3、Mark word里记录了：线程id、Epoch、对象的分代年龄信息、是否是偏向锁、锁标志位

轻量级锁：多个线程能同时获取到锁
jvm会把当前线程的栈针创建用于存储锁记录的空间，并将对象头的Mark word复制到锁记录中，然后，竞争锁，竞争到后，将锁标志位修改成轻量级锁
1、用到自旋
2、多个线程可以同时：自旋失败后，升级为重量级锁


重入锁：
自旋锁：


volatile:称之为轻量级锁，被volatile修饰的变量，在线程之间是可见的。
可见：一个线程修改了这个变量的值，在另外一个线程中能够读到这个修改后的值。
Synchronized处理线程之间互斥外，保证线程的可见性

公平锁：针对锁的获取而言的，锁是公平的，那么锁的获取顺序就应该符合   请求的绝对时间顺序。
非公平：

读写锁：排它锁与共享锁
